# SpringCqlTemplate

Our team was working with [Spring Data Cassandra](https://projects.spring.io/spring-data-cassandra/). We had queries that are run often so we began adding support for the `PreparedStatement` in our DAO. Like all Spring projects there are numerous ways to do this.

As we looked at the code we came across some potential enhancements for the `CqlTemplate`.

## Caching PreparedStatements
The first was the lack of a caching mechanism. This is documented in [DATACASS-555](https://jira.spring.io/browse/DATACASS-555). 

Running this query will generate a `SimplePreparedStatement` around the CQL

```cqlTemplate.query(SELECT_VENDOR_BY_DUNS_AND_COMM_ID,(row, rowNum) -> this.rowToVendorDetails(row), commId, duns);```

When this code is run multiple times a warning is generated by the DataStax driver. The warning is letting the team know that there is no need to continually re-prepare the statement. Instead it should be cached for repeated use. 

```
14:38:56.283 [main] DEBUG o.s.d.cassandra.core.cql.CqlTemplate - Executing CQL Statement [INSERT INTO vendor_details (duns,comm_id,vendor_name,vendor_id) VALUES ('222','111','vendor 2','v-id-2');]
...
14:39:18.994 [main] DEBUG o.s.d.cassandra.core.cql.CqlTemplate - Preparing statement [SELECT comm_id, duns, vendor_id, vendor_name FROM vendor_details WHERE comm_id = ? AND duns = ?] using org.springframework.data.cassandra.core.cql.CqlTemplate$SimplePreparedStatementCreator@2f860823
14:39:19.018 [main] DEBUG o.s.d.cassandra.core.cql.CqlTemplate - Executing prepared statement [com.datastax.driver.core.DefaultPreparedStatement@330c1f61]
...
14:39:22.091 [main] DEBUG o.s.d.cassandra.core.cql.CqlTemplate - Preparing statement [SELECT comm_id, duns, vendor_id, vendor_name FROM vendor_details WHERE comm_id = ? AND duns = ?] using org.springframework.data.cassandra.core.cql.CqlTemplate$SimplePreparedStatementCreator@58b91d57
14:39:22.094 [cluster-worker-1] WARN  com.datastax.driver.core.Cluster - Re-preparing already prepared query is generally an anti-pattern and will likely affect performance. Consider preparing the statement only once. Query='SELECT comm_id, duns, vendor_id, vendor_name FROM vendor_details WHERE comm_id = ? AND duns = ?'
```
Spring Data Cassandra provides an interface for caching a `PreparedStatement`. The `PreparedStatementCache` [API](https://docs.spring.io/spring-data/cassandra/docs/current/api/org/springframework/data/cassandra/core/cql/support/PreparedStatementCache.html) describes the interface. However, the `CqlTemplate` currently does not use this interface. This is due to the complexity of caching. 

Our team made some tweaks so that we could provide an implementation of the `PreparedStatementCache`. This attribute/variable can be set when the CqlTemplate is created through a setter. We are currently using the implementation provided in the Spring Data Cassandra project.

```
@Bean
public CqlTemplate cassandraCqlTemplate() {
   CqlTemplate ct = new CqlTemplate(cassandraSession());
   ct.setPreparedStatementCache(MapPreparedStatementCache.create());
   return ct;
}
```

## Adding methods that create PreparedStatements using RegularStatement
The second potential enhancement was overloading the `query` and `execute` methods so that the `CqlTemplate` would create and cache a `PreparedStatement` when it was provided with a DataStax `RegularStatement` [API](https://docs.datastax.com/en/drivers/java/3.4/com/datastax/driver/core/querybuilder/BuiltStatement.html). This provides the basis for the fluent API to build CQL. This is documented in [DATACASS-556](https://jira.spring.io/browse/DATACASS-556). 

The fluent API is certainly a nicer way to write CQL.

```
Select vendorSelect = QueryBuilder.select("vendor_id")
  .from("vendor_details");
vendorSelect.where(QueryBuilder.eq("duns", duns))
  .and(QueryBuilder.eq("comm_id", commId));

ResultSet rs = template.queryForResultSet(vendorSelect);
```

However, the `queryForResultSet` method does not use the `PreparedStatement`.
To do that we need to tweak our code as follows:

```
Select vendorSelect = QueryBuilder.select("vendor_id")
  .from("vendor_details");
vendorSelect.where(QueryBuilder.eq("duns", QueryBuilder.bindMarker()))
  .and(QueryBuilder.eq("comm_id", QueryBuilder.bindMarker()));

ResultSet rs = template.queryForResultSet(vendorSelect.getQueryString(), duns, commId);
```

This "enhanced" `CqlTemplate` adds some helper methods so that the user of the API doesn't have to call the `getQueryString`. This follows the existing pattern in the `CqlTemplate` of methods using varargs generating a `PreparedStatement`.  

```
Select vendorSelect = QueryBuilder.select("vendor_id")
  .from("vendor_details");
vendorSelect.where(QueryBuilder.eq("duns", QueryBuilder.bindMarker()))
  .and(QueryBuilder.eq("comm_id", QueryBuilder.bindMarker()));

ResultSet rs = template.queryForResultSet(vendorSelect, duns, commId);
```

